This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-09-08T09:05:35.595Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
.eslintrc.json
.gitignore
app/api/auth/login/route.ts
app/api/auth/register/route.ts
app/api/comments/route.ts
app/api/likes/route.ts
app/api/posts/route.ts
app/api/users/route.ts
app/components/CommentSection.tsx
app/components/Header.tsx
app/components/LoginForm.tsx
app/components/NewPostForm.tsx
app/components/PostCard.tsx
app/components/RegisterForm.tsx
app/contexts/AuthContext.tsx
app/globals.css
app/layout.tsx
app/login/page.tsx
app/page.tsx
app/profile/[userid]/page.tsx
app/register/page.tsx
lib/dbConnect.ts
models/Comment.ts
models/Like.ts
models/Post.ts
models/User.ts
next.config.mjs
package.json
postcss.config.mjs
README.md
structure.txt
tailwind.config.ts
tsconfig.json

================================================================
Repository Files
================================================================

================
File: .eslintrc.json
================
{
  "extends": ["next/core-web-vitals", "next/typescript"]
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js
.yarn/install-state.gz

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# local env files
.env*.local

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

================
File: app/api/auth/login/route.ts
================
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import User from '@/models/User';

export async function POST(request: Request) {
  await dbConnect();

  try {
    const { username, password } = await request.json();

    // Basic validation
    if (!username || !password) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    // Find user by username
    const user = await User.findOne({ username });
    if (!user) {
      return NextResponse.json({ success: false, message: 'Invalid credentials' }, { status: 401 });
    }

    // Check password
    const isMatch = await user.comparePassword(password);
    if (!isMatch) {
      return NextResponse.json({ success: false, message: 'Invalid credentials' }, { status: 401 });
    }

    // Login successful
    // For now, we'll just return a success message
    // In a real app, you'd set up a session or return a JWT here
    return NextResponse.json({ 
      success: true, 
      message: 'Login successful',
      user: { id: user._id, username: user.username, name: user.name }
    });

  } catch (error) {
    console.error('Login error:', error);
    return NextResponse.json({ success: false, message: 'An error occurred during login' }, { status: 500 });
  }
}

================
File: app/api/auth/register/route.ts
================
import { NextResponse } from 'next/server';
import dbConnect from '@/lib/dbConnect';
import User from '@/models/User';

export async function POST(request: Request) {
  await dbConnect();

  try {
    const { username, password, name } = await request.json();

    // Basic validation
    if (!username || !password || !name) {
      return NextResponse.json({ success: false, message: 'Missing required fields' }, { status: 400 });
    }

    // Check if user already exists
    const existingUser = await User.findOne({ username });
    if (existingUser) {
      return NextResponse.json({ success: false, message: 'Username already exists' }, { status: 400 });
    }

    // Create new user
    const user = await User.create({ username, password, name });

    return NextResponse.json({ success: true, message: 'User registered successfully' }, { status: 201 });
  } catch (error) {
    console.error('Registration error:', error);
    return NextResponse.json({ success: false, message: 'An error occurred during registration' }, { status: 500 });
  }
}

================
File: app/api/comments/route.ts
================
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Comment from "@/models/Comment";

export async function GET(request: Request) {
  await dbConnect();
  const { searchParams } = new URL(request.url);
  const postId = searchParams.get("postId");

  if (!postId) {
    return NextResponse.json({ success: false, error: "Post ID is required" }, { status: 400 });
  }

  try {
    const comments = await Comment.find({ post: postId }).populate("user", "username name").sort({ createdAt: -1 });
    return NextResponse.json({ success: true, data: comments });
  } catch (error) {
    return NextResponse.json({ success: false, error: "Failed to fetch comments" }, { status: 500 });
  }
}

export async function POST(request: Request) {
  await dbConnect();
  const { userId, postId, content } = await request.json();

  try {
    const comment = await Comment.create({ user: userId, post: postId, content });
    return NextResponse.json({ success: true, data: comment });
  } catch (error) {
    return NextResponse.json({ success: false, error: "Comment creation failed" }, { status: 400 });
  }
}

================
File: app/api/likes/route.ts
================
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Like from "@/models/Like";

export async function POST(request: Request) {
  await dbConnect();
  const { userId, postId } = await request.json();

  try {
    const existingLike = await Like.findOne({ user: userId, post: postId });
    if (existingLike) {
      await Like.findByIdAndDelete(existingLike._id);
      return NextResponse.json({ success: true, message: "Like removed" });
    } else {
      const like = await Like.create({ user: userId, post: postId });
      return NextResponse.json({ success: true, data: like });
    }
  } catch (error) {
    return NextResponse.json({ success: false, error: "Like operation failed" }, { status: 400 });
  }
}

export async function GET(request: Request) {
  await dbConnect();
  const { searchParams } = new URL(request.url);
  const postId = searchParams.get("postId");

  if (!postId) {
    return NextResponse.json({ success: false, error: "Post ID is required" }, { status: 400 });
  }

  try {
    const likeCount = await Like.countDocuments({ post: postId });
    return NextResponse.json({ success: true, data: { count: likeCount } });
  } catch (error) {
    return NextResponse.json({ success: false, error: "Failed to fetch like count" }, { status: 500 });
  }
}

================
File: app/api/posts/route.ts
================
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import Post from "@/models/Post";

export async function GET() {
  try {
    await dbConnect();

    const posts = await Post.find()
      .populate("user", "username name")
      .sort({ createdAt: -1 })
      .limit(50);
    
    console.log("Fetched posts:", posts);
    return NextResponse.json({ success: true, data: posts });
  } catch (error) {
    console.error("Failed to fetch posts:", error);
    if (error instanceof Error) {
      return NextResponse.json({ success: false, error: error.message }, { status: 500 });
    }
    return NextResponse.json({ success: false, error: "An unknown error occurred" }, { status: 500 });
  }
}


export async function POST(request: Request) {
  await dbConnect();
  
  try {
    const body = await request.json();
    console.log("Received data in POST /api/posts:", body);

    const { userId, content } = body;

    if (!userId) {
      console.log("Missing userId");
      return NextResponse.json({ success: false, error: "Missing userId" }, { status: 400 });
    }

    if (!content) {
      console.log("Missing content");
      return NextResponse.json({ success: false, error: "Missing content" }, { status: 400 });
    }

    const post = await Post.create({ user: userId, content });
    console.log("Created post:", post);
    return NextResponse.json({ success: true, data: post });
  } catch (error) {
    console.error("Post creation error:", error);
    if (error instanceof Error) {
      return NextResponse.json({ success: false, error: "Post creation failed", details: error.message }, { status: 400 });
    }
    return NextResponse.json({ success: false, error: "Post creation failed" }, { status: 400 });
  }
}

================
File: app/api/users/route.ts
================
import { NextResponse } from "next/server";
import dbConnect from "@/lib/dbConnect";
import User from "@/models/User";

export async function POST(request: Request) {
  await dbConnect();
  const { username, password, name } = await request.json();

  try {
    const user = await User.create({ username, password, name });
    return NextResponse.json({ success: true, data: user });
  } catch (error) {
    return NextResponse.json({ success: false, error: "User creation failed" }, { status: 400 });
  }
}

================
File: app/components/CommentSection.tsx
================
import React, { useState, useEffect } from 'react';
import { Box, Typography, TextField, Button, List, ListItem, ListItemText } from '@mui/material';

interface Comment {
  _id: string;
  content: string;
  user: {
    username: string;
    name: string;
  };
  createdAt: string;
}

interface CommentSectionProps {
  postId: string;
}

const CommentSection: React.FC<CommentSectionProps> = ({ postId }) => {
  const [comments, setComments] = useState<Comment[]>([]);
  const [newComment, setNewComment] = useState('');

  useEffect(() => {
    fetchComments();
  }, [postId]);

  const fetchComments = async () => {
    try {
      const response = await fetch(`/api/comments?postId=${postId}`);
      const data = await response.json();
      if (data.success) {
        setComments(data.data);
      }
    } catch (error) {
      console.error('Failed to fetch comments:', error);
    }
  };

  const handleSubmitComment = async () => {
    try {
      const response = await fetch('/api/comments', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({
          postId,
          content: newComment,
          userId: 'placeholder-user-id', // TODO: Replace with actual user ID when auth is implemented
        }),
      });
      const data = await response.json();
      if (data.success) {
        setNewComment('');
        fetchComments();
      }
    } catch (error) {
      console.error('Failed to submit comment:', error);
    }
  };

  return (
    <Box>
      <Typography variant="h6">Comments</Typography>
      <List>
        {comments.map((comment) => (
          <ListItem key={comment._id}>
            <ListItemText
              primary={comment.user.name}
              secondary={
                <>
                  <Typography component="span" variant="body2" color="text.primary">
                    {comment.content}
                  </Typography>
                  {" — "}{new Date(comment.createdAt).toLocaleString()}
                </>
              }
            />
          </ListItem>
        ))}
      </List>
      <Box component="form" onSubmit={(e) => { e.preventDefault(); handleSubmitComment(); }}>
        <TextField
          fullWidth
          variant="outlined"
          placeholder="Write a comment..."
          value={newComment}
          onChange={(e) => setNewComment(e.target.value)}
          margin="normal"
        />
        <Button type="submit" variant="contained" color="primary">
          Post Comment
        </Button>
      </Box>
    </Box>
  );
};

export default CommentSection;

================
File: app/components/Header.tsx
================
"use client";
import React from 'react';
import { AppBar, Toolbar, Typography, Button, Box } from '@mui/material';
import Link from 'next/link';
import { useAuth } from '../contexts/AuthContext';
import { useRouter } from 'next/navigation';

const Header = () => {
  const { user, logout } = useAuth();
  const router = useRouter();

  const handleLogout = () => {
    logout();
    router.push('/login');
  };

  if (!user) {
    return null;
  }

  return (
    <AppBar position="static">
      <Toolbar>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1 }}>
          <Link href="/" passHref legacyBehavior>
            <Typography
              component="a"
              sx={{
                color: 'inherit',
                textDecoration: 'none',
                '&:hover': {
                  textDecoration: 'underline',
                },
              }}
            >
              Social Media
            </Typography>
          </Link>
        </Typography>
        <Box>
          <Typography sx={{ mr: 2 }} component="span">Welcome, {user.name}</Typography>
          <Button color="inherit" onClick={handleLogout}>Logout</Button>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Header;

================
File: app/components/LoginForm.tsx
================
"use client";
import React, { useState } from 'react';
import { Box, TextField, Button, Typography, Container, Link as MuiLink } from '@mui/material';
import Link from 'next/link';
import { useRouter } from 'next/navigation';
import { toast } from 'react-toastify';
import { useAuth } from '../contexts/AuthContext';

const LoginForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();
  const { login } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password }),
      });

      const data = await response.json();

      if (response.ok) {
        // Login successful
        toast.success('Login successful!');
        console.log('Login successful:', data.user);
        
        // Update the auth context with the user data
        login(data.user);
        
        // Redirect to the home page
        router.push('/');
      } else {
        // Login failed, display error message
        toast.error(data.message || 'Login failed');
        setError(data.message || 'Login failed');
      }
    } catch (error) {
      setError('An error occurred. Please try again.');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          Sign In
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1, width: '100%' }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="username"
            label="Username"
            name="username"
            autoComplete="username"
            autoFocus
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="current-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Sign In
          </Button>
          {error && (
            <Typography color="error" align="center">
              {error}
            </Typography>
          )}
          <Box sx={{ textAlign: 'center' }}>
            <Link href="/register" passHref>
              <MuiLink variant="body2">
                {"Don't have an account? Register here"}
              </MuiLink>
            </Link>
          </Box>
        </Box>
      </Box>
    </Container>
  );
};

export default LoginForm;

================
File: app/components/NewPostForm.tsx
================
"use client";
import { useState } from "react";
import { Box, TextField, Button } from "@mui/material";
import { useAuth } from '../contexts/AuthContext';

export default function NewPostForm() {
  const [content, setContent] = useState("");
  const { user } = useAuth();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    try {
      const response = await fetch("/api/posts", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ content, userId: user?.id }),
      });
      
      if (response.ok) {
        console.log("Post created successfully");
        setContent("");
        // Trigger a re-render of the parent component
        window.dispatchEvent(new CustomEvent('newpost'));
      } else {
        const errorData = await response.json();
        console.error("Failed to create post:", errorData);
      }
    } catch (error) {
      console.error("Error creating post:", error);
    }
  };

  return (
    <Box component="form" onSubmit={handleSubmit} sx={{ marginBottom: 2 }}>
      <TextField
        fullWidth
        variant="outlined"
        placeholder="What's on your mind?"
        value={content}
        onChange={(e) => setContent(e.target.value)}
        multiline
        rows={3}
      />
      <Button
        type="submit"
        variant="contained"
        sx={{ marginTop: 1 }}
      >
        Post
      </Button>
    </Box>
  );
}

================
File: app/components/PostCard.tsx
================
import React from 'react';
import { Card, CardContent, Typography, Avatar, Box } from '@mui/material';

interface Post {
  _id: string;
  content: string;
  user: {
    _id: string;
    username: string;
    name: string;
  };
  createdAt: string;
}

interface PostCardProps {
  post: Post;
}

const PostCard: React.FC<PostCardProps> = ({ post }) => {
  return (
    <Card sx={{ marginBottom: 2 }}>
      <CardContent>
        <Box display="flex" alignItems="center" mb={2}>
          <Avatar sx={{ mr: 2 }}>{post.user.name[0]}</Avatar>
          <Box>
            <Typography variant="h6">{post.user.name}</Typography>
            <Typography variant="body2" color="text.secondary">
              @{post.user.username}
            </Typography>
          </Box>
        </Box>
        <Typography variant="body1" sx={{ mb: 2 }}>
          {post.content}
        </Typography>
        <Typography variant="caption" color="text.secondary">
          {new Date(post.createdAt).toLocaleString()}
        </Typography>
      </CardContent>
    </Card>
  );
};

export default PostCard;

================
File: app/components/RegisterForm.tsx
================
"use client";
import React, { useState } from 'react';
import { Box, Typography, TextField, Button, Container } from '@mui/material';
import { useRouter } from 'next/navigation';
import { toast } from 'react-toastify';

const RegisterForm = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [error, setError] = useState('');
  const router = useRouter();

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError('');

    try {
      const response = await fetch('/api/auth/register', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ username, password, name }),
      });

      const data = await response.json();

      if (response.ok) {
        // Registration successful, redirect to login page
        toast.success('Registration successful! Please log in.');
        router.push('/login');
      } else {
        // Registration failed, display error message
        toast.error(data.message || 'Registration failed');
        setError(data.message || 'Registration failed');
      }
    } catch (error) {
      toast.error('An error occurred. Please try again.');
      setError('An error occurred. Please try again.');
    }
  };

  return (
    <Container component="main" maxWidth="xs">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h5">
          Register
        </Typography>
        <Box component="form" onSubmit={handleSubmit} sx={{ mt: 1 }}>
          <TextField
            margin="normal"
            required
            fullWidth
            id="name"
            label="Full Name"
            name="name"
            autoComplete="name"
            autoFocus
            value={name}
            onChange={(e) => setName(e.target.value)}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            id="username"
            label="Username"
            name="username"
            autoComplete="username"
            value={username}
            onChange={(e) => setUsername(e.target.value)}
          />
          <TextField
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete="new-password"
            value={password}
            onChange={(e) => setPassword(e.target.value)}
          />
          <Button
            type="submit"
            fullWidth
            variant="contained"
            sx={{ mt: 3, mb: 2 }}
          >
            Register
          </Button>
          {error && (
            <Typography color="error" align="center">
              {error}
            </Typography>
          )}
        </Box>
      </Box>
    </Container>
  );
};

export default RegisterForm;

================
File: app/contexts/AuthContext.tsx
================
// app/contexts/AuthContext.tsx
"use client";

import React, { createContext, useState, useContext, useEffect } from 'react';

type User = {
  id: string;
  username: string;
  name: string;
};

type AuthContextType = {
  user: User | null;
  login: (user: User) => void;
  logout: () => void;
  isLoading: boolean;
};

const AuthContext = createContext<AuthContextType | undefined>(undefined);

export const AuthProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    // Check localStorage for user data on initial load
    const storedUser = localStorage.getItem('user');
    if (storedUser) {
      setUser(JSON.parse(storedUser));
    }
    setIsLoading(false);
  }, []);

  const login = (userData: User) => {
    setUser(userData);
    localStorage.setItem('user', JSON.stringify(userData));
  };

  const logout = () => {
    setUser(null);
    localStorage.removeItem('user');
  };

  return (
    <AuthContext.Provider value={{ user, login, logout, isLoading }}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (context === undefined) {
    throw new Error('useAuth must be used within an AuthProvider');
  }
  return context;
};

================
File: app/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

:root {
  --background: #ffffff;
  --foreground: #171717;
}

/* Remove or comment out the media query for dark mode */
/*
@media (prefers-color-scheme: dark) {
  :root {
    --background: #0a0a0a;
    --foreground: #ededed;
  }
}
*/

body {
  color: var(--foreground);
  background: var(--background);
  font-family: Arial, Helvetica, sans-serif;
}

@layer utilities {
  .text-balance {
    text-wrap: balance;
  }
}

================
File: app/layout.tsx
================
"use client";

import type { Metadata } from "next";
import localFont from "next/font/local";
import "./globals.css";
import { ToastContainer } from 'react-toastify';
import 'react-toastify/dist/ReactToastify.css';
import { AuthProvider } from './contexts/AuthContext';

const geistSans = localFont({
  src: "./fonts/GeistVF.woff",
  variable: "--font-geist-sans",
  weight: "100 900",
});
const geistMono = localFont({
  src: "./fonts/GeistMonoVF.woff",
  variable: "--font-geist-mono",
  weight: "100 900",
});

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body className={`${geistSans.variable} ${geistMono.variable} antialiased`}>
        <AuthProvider>
          {children}
          <ToastContainer />
        </AuthProvider>
      </body>
    </html>
  );
}

================
File: app/login/page.tsx
================
// app/login/page.tsx
import LoginForm from '../components/LoginForm';

export default function LoginPage() {
  return (
    <div>
      <h1>Login</h1>
      <LoginForm />
    </div>
  );
}

================
File: app/page.tsx
================
"use client";
import { Box, Typography, CircularProgress } from "@mui/material";
import Header from "./components/Header";
import PostCard from "./components/PostCard";
import NewPostForm from "./components/NewPostForm";
import { useEffect, useState, useCallback } from "react";
import { useAuth } from "./contexts/AuthContext";

interface Post {
  _id: string;
  content: string;
  user: {
    _id: string;
    username: string;
    name: string;
  };
  createdAt: string;
}

export default function Home() {
  const [posts, setPosts] = useState<Post[]>([]);
  const [loading, setLoading] = useState(true);
  const { isLoading: authLoading, user } = useAuth();

  const fetchPosts = useCallback(async () => {
    try {
      console.log("Fetching posts...");
      const response = await fetch('/api/posts');
      const data = await response.json();
      if (data.success) {
        console.log("Fetched posts:", data.data);
        setPosts(data.data);
      }
    } catch (error) {
      console.error('Failed to fetch posts:', error);
    } finally {
      setLoading(false);
    }
  }, []);

  useEffect(() => {
    if (!authLoading && user) {
      fetchPosts();
    }
  }, [authLoading, user, fetchPosts]);

  useEffect(() => {
    const handleNewPost = () => {
      fetchPosts();
    };

    window.addEventListener('newpost', handleNewPost);

    return () => {
      window.removeEventListener('newpost', handleNewPost);
    };
  }, [fetchPosts]);

  if (authLoading || loading) {
    return (
      <Box display="flex" justifyContent="center" alignItems="center" minHeight="100vh">
        <CircularProgress />
      </Box>
    );
  }

  if (!user) {
    return null; // or redirect to login
  }

  return (
    <Box>
      <Header />
      <Box sx={{ maxWidth: 600, margin: "0 auto", padding: 2 }}>
        <Typography variant="h4" component="h1" gutterBottom>
          Social Media Feed
        </Typography>
        <NewPostForm />
        {posts.map((post) => (
          <PostCard key={post._id} post={post} />
        ))}
      </Box>
    </Box>
  );
}

================
File: app/profile/[userid]/page.tsx
================
// app/profile/[userId]/page.tsx
import { notFound } from 'next/navigation';
import { Box, Typography, Container, Avatar } from '@mui/material';
import Header from '../../components/Header';
import PostCard from '../../components/PostCard';
import dbConnect from '@/lib/dbConnect';
import User from '@/models/User';
import Post from '@/models/Post';

async function getUser(userId: string) {
  await dbConnect();
  const user = await User.findById(userId);
  if (!user) {
    notFound();
  }
  return user;
}

async function getUserPosts(userId: string) {
  await dbConnect();
  const posts = await Post.find({ user: userId }).sort({ createdAt: -1 }).populate('user', 'username name');
  return posts;
}

export default async function ProfilePage({ params }: { params: { userId: string } }) {
  const user = await getUser(params.userId);
  const posts = await getUserPosts(params.userId);

  return (
    <Box>
      <Header />
      <Container maxWidth="md">
        <Box sx={{ mt: 4, mb: 4, textAlign: 'center' }}>
          <Avatar sx={{ width: 100, height: 100, margin: '0 auto' }}>{user.name[0]}</Avatar>
          <Typography variant="h4" sx={{ mt: 2 }}>{user.name}</Typography>
          <Typography variant="subtitle1" color="text.secondary">@{user.username}</Typography>
          <Typography variant="body1" sx={{ mt: 2 }}>{user.bio}</Typography>
        </Box>
        <Typography variant="h5" sx={{ mb: 2 }}>Posts</Typography>
        {posts.map((post) => (
          <PostCard key={post._id.toString()} post={post} />
        ))}
      </Container>
    </Box>
  );
}

================
File: app/register/page.tsx
================
import React from 'react';
import { Box, Typography, Container } from '@mui/material';
import Header from '../components/Header';
import RegisterForm from '../components/RegisterForm';

const RegisterPage = () => {
  return (
    <Box>
      <Header />
      <Container component="main" maxWidth="xs">
        <Box
          sx={{
            marginTop: 8,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Typography component="h1" variant="h5">
            Register
          </Typography>
          <RegisterForm />
        </Box>
      </Container>
    </Box>
  );
};

export default RegisterPage;

================
File: lib/dbConnect.ts
================
import mongoose from "mongoose";

// Import all models
import "../models/User";
import "../models/Post";
import "../models/Comment";
import "../models/Like";

declare global {
  var mongoose: any;
}

const MONGODB_URI = process.env.MONGODB_URI!;

if (!MONGODB_URI) {
  throw new Error(
    "Please define the MONGODB_URI environment variable inside .env.local"
  );
}

let cached = global.mongoose;

if (!cached) {
  cached = global.mongoose = { conn: null, promise: null };
}

async function dbConnect() {
  if (cached.conn) {
    console.log("Using existing database connection");
    return cached.conn;
  }

  if (!cached.promise) {
    const opts = {
      bufferCommands: false,
    };

    cached.promise = mongoose.connect(MONGODB_URI, opts).then((mongoose) => {
      console.log("New database connection established");
      return mongoose;
    });
  }

  try {
    cached.conn = await cached.promise;
  } catch (e) {
    cached.promise = null;
    console.error("Failed to connect to database:", e);
    throw e;
  }

  return cached.conn;
}

export default dbConnect;

================
File: models/Comment.ts
================
import mongoose from "mongoose";

const CommentSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  post: { type: mongoose.Schema.Types.ObjectId, ref: "Post", required: true },
  content: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.models.Comment || mongoose.model("Comment", CommentSchema);

================
File: models/Like.ts
================
import mongoose from "mongoose";

const LikeSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  post: { type: mongoose.Schema.Types.ObjectId, ref: "Post", required: true },
});

export default mongoose.models.Like || mongoose.model("Like", LikeSchema);

================
File: models/Post.ts
================
import mongoose from "mongoose";
import "./User"; // Import User model to ensure it's registered

const PostSchema = new mongoose.Schema({
  user: { type: mongoose.Schema.Types.ObjectId, ref: "User", required: true },
  content: { type: String, required: true },
  createdAt: { type: Date, default: Date.now },
});

export default mongoose.models.Post || mongoose.model("Post", PostSchema);

================
File: models/User.ts
================
import mongoose from "mongoose";
import bcrypt from 'bcryptjs';

const UserSchema = new mongoose.Schema({
  username: { type: String, required: true, unique: true },
  password: { type: String, required: true },
  name: { type: String, required: true },
  bio: { type: String, default: "" },
});

// Hash password before saving
UserSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(10);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error: any) {
    next(error);
  }
});

// Method to check password
UserSchema.methods.comparePassword = async function(candidatePassword: string) {
  return bcrypt.compare(candidatePassword, this.password);
};

export default mongoose.models.User || mongoose.model("User", UserSchema);

================
File: next.config.mjs
================
/** @type {import('next').NextConfig} */
const nextConfig = {};

export default nextConfig;

================
File: package.json
================
{
  "name": "final-project",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@emotion/react": "^11.13.3",
    "@emotion/styled": "^11.13.0",
    "@mui/icons-material": "^6.0.2",
    "@mui/material": "^6.0.2",
    "bcryptjs": "^2.4.3",
    "mongoose": "^8.2.0",
    "next": "14.2.8",
    "react": "^18",
    "react-dom": "^18",
    "react-toastify": "^10.0.5"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/node": "^20",
    "@types/react": "^18",
    "@types/react-dom": "^18",
    "eslint": "^8",
    "eslint-config-next": "14.2.8",
    "postcss": "^8",
    "tailwindcss": "^3.4.1",
    "typescript": "^5"
  }
}

================
File: postcss.config.mjs
================
/** @type {import('postcss-load-config').Config} */
const config = {
  plugins: {
    tailwindcss: {},
  },
};

export default config;

================
File: README.md
================
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

```bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
```

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

================
File: structure.txt
================
├── app/
│   ├── api/
│   │   ├── comments/
│   │   │   └── route.ts
│   │   ├── likes/
│   │   │   └── route.ts
│   │   ├── posts/
│   │   │   └── route.ts
│   │   └── users/
│   │       └── route.ts
│   ├── components/
│   │   ├── CommentSection.tsx
│   │   ├── Header.tsx
│   │   ├── LoginForm.tsx
│   │   ├── NewPostForm.tsx
│   │   ├── PostCard.tsx
│   │   └── RegisterForm.tsx
│   ├── login/
│   │   └── page.tsx
│   ├── profile/
│   │   └── [userid]/
│   │       └── page.tsx
│   ├── register/
│   │   └── page.tsx
│   ├── globals.css
│   ├── layout.tsx
│   └── page.tsx
├── lib/
│   └── dbConnect.ts
├── models/
│   ├── Comment.ts
│   ├── Like.ts
│   ├── Post.ts
│   └── User.ts
├── .eslintrc.json
├── .gitignore
├── next.config.mjs
├── package.json
├── postcss.config.mjs
├── README.md
├── tailwind.config.ts
└── tsconfig.json

================
File: tailwind.config.ts
================
import type { Config } from "tailwindcss";

const config: Config = {
  content: [
    "./pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./components/**/*.{js,ts,jsx,tsx,mdx}",
    "./app/**/*.{js,ts,jsx,tsx,mdx}",
  ],
  theme: {
    extend: {
      colors: {
        background: "var(--background)",
        foreground: "var(--foreground)",
      },
    },
  },
  plugins: [],
};
export default config;

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}
